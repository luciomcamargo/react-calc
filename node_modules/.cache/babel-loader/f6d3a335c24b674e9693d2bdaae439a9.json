{"ast":null,"code":"'use strict';\n\nvar operators = require('../operators');\n\nfunction factory(type, config, load, typed) {\n  var Node = load(require('./Node'));\n  var mathTypeOf = load(require('../../function/utils/typeof'));\n  /**\n   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n   *\n   * @param {Node} condition   Condition, must result in a boolean\n   * @param {Node} trueExpr    Expression evaluated when condition is true\n   * @param {Node} falseExpr   Expression evaluated when condition is true\n   *\n   * @constructor ConditionalNode\n   * @extends {Node}\n   */\n\n  function ConditionalNode(condition, trueExpr, falseExpr) {\n    if (!(this instanceof ConditionalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!type.isNode(condition)) throw new TypeError('Parameter condition must be a Node');\n    if (!type.isNode(trueExpr)) throw new TypeError('Parameter trueExpr must be a Node');\n    if (!type.isNode(falseExpr)) throw new TypeError('Parameter falseExpr must be a Node');\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n\n  ConditionalNode.prototype = new Node();\n  ConditionalNode.prototype.type = 'ConditionalNode';\n  ConditionalNode.prototype.isConditionalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ConditionalNode.prototype._compile = function (math, argNames) {\n    var evalCondition = this.condition._compile(math, argNames);\n\n    var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n    var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n    return function evalConditionalNode(scope, args, context) {\n      return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ConditionalNode.prototype.forEach = function (callback) {\n    callback(this.condition, 'condition', this);\n    callback(this.trueExpr, 'trueExpr', this);\n    callback(this.falseExpr, 'falseExpr', this);\n  };\n  /**\n   * Create a new ConditionalNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ConditionalNode} Returns a transformed copy of the node\n   */\n\n\n  ConditionalNode.prototype.map = function (callback) {\n    return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ConditionalNode}\n   */\n\n\n  ConditionalNode.prototype.clone = function () {\n    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = operators.getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toString(options);\n    var conditionPrecedence = operators.getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '(' + condition + ')';\n    }\n\n    var trueExpr = this.trueExpr.toString(options);\n    var truePrecedence = operators.getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '(' + trueExpr + ')';\n    }\n\n    var falseExpr = this.falseExpr.toString(options);\n    var falsePrecedence = operators.getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '(' + falseExpr + ')';\n    }\n\n    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ConditionalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ConditionalNode',\n      condition: this.condition,\n      trueExpr: this.trueExpr,\n      falseExpr: this.falseExpr\n    };\n  };\n  /**\n   * Instantiate an ConditionalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ConditionalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {ConditionalNode}\n   */\n\n\n  ConditionalNode.fromJSON = function (json) {\n    return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = operators.getPrecedence(this, parenthesis); // Enclose Arguments in parentheses if they are an OperatorNode\n    // or have lower or equal precedence\n    // NOTE: enclosing all OperatorNodes in parentheses is a decision\n    // purely based on aesthetics and readability\n\n    var condition = this.condition.toHTML(options);\n    var conditionPrecedence = operators.getPrecedence(this.condition, parenthesis);\n\n    if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n      condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var trueExpr = this.trueExpr.toHTML(options);\n    var truePrecedence = operators.getPrecedence(this.trueExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n      trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    var falseExpr = this.falseExpr.toHTML(options);\n    var falsePrecedence = operators.getPrecedence(this.falseExpr, parenthesis);\n\n    if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n      falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ConditionalNode.prototype._toTex = function (options) {\n    return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n  };\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if (type.isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n\n      if (type.isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if (type.isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + mathTypeOf(condition) + '\"');\n  }\n\n  return ConditionalNode;\n}\n\nexports.name = 'ConditionalNode';\nexports.path = 'expression.node';\nexports.factory = factory;","map":null,"metadata":{},"sourceType":"script"}