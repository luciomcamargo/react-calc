{"ast":null,"code":"'use strict';\n\nfunction factory() {\n  /**\n   * Depth-first search and postorder of a tree rooted at node j\n   *\n   * @param {Number}  j               The tree node\n   * @param {Number}  k\n   * @param {Array}   w               The workspace array\n   * @param {Number}  head            The index offset within the workspace for the head array\n   * @param {Number}  next            The index offset within the workspace for the next array\n   * @param {Array}   post            The post ordering array\n   * @param {Number}  stack           The index offset within the workspace for the stack array\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n  var csTdfs = function csTdfs(j, k, w, head, next, post, stack) {\n    // variables\n    var top = 0; // place j on the stack\n\n    w[stack] = j; // while (stack is not empty)\n\n    while (top >= 0) {\n      // p = top of stack\n      var p = w[stack + top]; // i = youngest child of p\n\n      var i = w[head + p];\n\n      if (i === -1) {\n        // p has no unordered children left\n        top--; // node p is the kth postordered node\n\n        post[k++] = p;\n      } else {\n        // remove i from children of p\n        w[head + p] = w[next + i]; // increment top\n\n        ++top; // start dfs on child node i\n\n        w[stack + top] = i;\n      }\n    }\n\n    return k;\n  };\n\n  return csTdfs;\n}\n\nexports.name = 'csTdfs';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","map":null,"metadata":{},"sourceType":"script"}