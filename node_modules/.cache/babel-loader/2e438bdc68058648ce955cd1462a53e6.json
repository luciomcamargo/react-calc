{"ast":null,"code":"'use strict';\n\nfunction factory(type, config, load) {\n  var csDfs = load(require('./csDfs'));\n  var csMarked = load(require('./csMarked'));\n  var csMark = load(require('./csMark'));\n  /**\n   * The csReach function computes X = Reach(B), where B is the nonzero pattern of the n-by-1\n   * sparse column of vector b. The function returns the set of nodes reachable from any node in B. The\n   * nonzero pattern xi of the solution x to the sparse linear system Lx=b is given by X=Reach(B).\n   *\n   * @param {Matrix}  g               The G matrix\n   * @param {Matrix}  b               The B matrix\n   * @param {Number}  k               The kth column in B\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n   * @param {Array}   pinv            The inverse row permutation vector\n   *\n   * @return {Number}                 The index for the nonzero pattern\n   *\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n   */\n\n  var csReach = function csReach(g, b, k, xi, pinv) {\n    // g arrays\n    var gptr = g._ptr;\n    var gsize = g._size; // b arrays\n\n    var bindex = b._index;\n    var bptr = b._ptr; // columns\n\n    var n = gsize[1]; // vars\n\n    var p, p0, p1; // initialize top\n\n    var top = n; // loop column indeces in B\n\n    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n      // node i\n      var i = bindex[p]; // check node i is marked\n\n      if (!csMarked(gptr, i)) {\n        // start a dfs at unmarked node i\n        top = csDfs(i, g, top, xi, pinv);\n      }\n    } // loop columns from top -> n - 1\n\n\n    for (p = top; p < n; p++) {\n      // restore G\n      csMark(gptr, xi[p]);\n    }\n\n    return top;\n  };\n\n  return csReach;\n}\n\nexports.name = 'csReach';\nexports.path = 'algebra.sparse';\nexports.factory = factory;","map":null,"metadata":{},"sourceType":"script"}